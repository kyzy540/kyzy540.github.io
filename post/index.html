<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | 低质量随笔</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - 低质量随笔">
<meta name="author" content="">
<link rel="canonical" href="https://kyzy540.github.io/post/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5c0f21e25c3551fd5c4685517c592eb41f5073118ce154d59fa4fd79f71c15c3.css" integrity="sha256-XA8h4lw1Uf1cRoVRfFkutB9QcxGM4VTVn6T9efccFcM=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kyzy540.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://kyzy540.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kyzy540.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://kyzy540.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://kyzy540.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://kyzy540.github.io/post/index.xml">
<link rel="alternate" hreflang="en" href="https://kyzy540.github.io/post/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://kyzy540.github.io/post/">
  <meta property="og:site_name" content="低质量随笔">
  <meta property="og:title" content="Posts">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Posts">
<meta name="twitter:description" content="">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://kyzy540.github.io/post/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kyzy540.github.io/" accesskey="h" title="低质量随笔 (Alt + H)">低质量随笔</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://kyzy540.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://kyzy540.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://kyzy540.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">《三相奇谈》吹得有点过
    </h2>
  </header>
  <div class="entry-content">
    <p>游戏不赖，但没B站推荐视频里吹得那么好。可能steam上叫好不叫座是它最好的结果。品类小众，品质一般，愿意吆喝的留好评。像我这样评价一般的，看在它国产份上，就不留评价了。大概买完退款也大有人在
它的第一个缺陷是太过“奇谈”。造了不少新词儿，却没讲明白。背景设定不是现代、古代、武侠、奇幻，却都杂糅了一点要素。这使得故事没法按常理推导。好处是方便作者叙事，说啥是啥，坏处是读者难以共情——随您老爷的便吧。作者借由优势搭了一套不错故事框架。有伏笔、回收、收尾呼应、多层嵌套等巧妙设计。好似精巧的榫卯器具。但忽律框架看内容的话，很多细节经不起推敲，多了以后读者就放弃思考了
榫卯设计巧，但器具不好用
游戏另一个缺陷是游戏细节打磨。比Flash时代的作品强点儿，但有限。主角动作缺动画帧 和 静态背景不能动是最直观的两大问题。游戏的美术基调是精细动漫风格，人物立绘和表情做得都挺丰富。游戏帧率稳60。在整体精细的美术基础上，游戏“动起来”缺乏细节，就显得很突兀。更糟的是，它用了2D平台跳跃的操作逻辑。这门类已经被各大厂钻研得很深，做得简陋落差很明显。不显好
为什么我要批评一款已经处境艰难的国产游戏？因为我也曾幻想过做一款这样的游戏，还自以为肯定有戏！
从创作者角度看，我喜欢看故事，如果让我主要一款游戏，一定会以叙事为主导。小成本叙事游戏大多是文字AVG，我不喜欢——光立绘加背景，太枯燥。AVG无法直观展现“动态”，哪怕是场景变化也只能靠文字描述。电子游戏有那么强表现力，玩儿AVG有点大材小用。况且有《逆转裁判》珠玉在前。想做好玩儿的AVG，得加入大量小游戏、小设计、小巧思，很考验创意，非我所长。还有其他适合叙事的游戏类型吗？有，45%俯视角，但它很考验场景建模，这门类佳作更多
顺这思路，我很自然想到了2D平台跳跃。我把2D平台看作45%俯视角的廉价版，足够放个人物在里面互动。而且2D美术资产比3D好做，可以腾出精力做的更精细—— 不做像素风格
都202x年了，咋还止步像素，不思进取呢？现代引擎这么厉害，把精细2D美术兑上去不比像素好看百倍？人不能越活越倒退
但实际玩到《三相奇谈》，我才明白独立游戏偏爱像素风格大有道理——可以放肆抽帧，放肆粗糙，动作缺帧是风格。像素风格给创作者的容错空间很大。如果做2D平台，地板可以用小方格复制平铺，没人介意。背景能动最好，不能动的话做2层，远景和近景，不等速滚动也就够了
如果非要做精细美术风格怎么办？《山河旅探》给了个不错的方案——别做平台跳跃，做小场景，仅够点击互动。《山》在互动方面做的很克制，主玩的还是文字AVG。再加上贴合历史题材，口碑和销量双丰收
归根结底，我批评《三相奇谈》不完全针对作品，还是为了自我反省。退一步说，它打折卖30多元，故事完整，有创意，没有恶性bug，已经很厉害了
</p>
  </div>
  <footer class="entry-footer"><span title='2026-01-31 09:04:21 +0800 CST'>January 31, 2026</span></footer>
  <a class="entry-link" aria-label="post link to 《三相奇谈》吹得有点过" href="https://kyzy540.github.io/post/threefold_recital/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Kombu &#43; Redis的Worker发现
    </h2>
  </header>
  <div class="entry-content">
    <p>分布式系统中，发现远端worker是一种常见需求。例如：一个计算任务需要GPU，而集群中只有少数机器配备。常见思路是让 管控/调度服务 发现GPU机部（worker），并把计算任务代理给worker执行，接收返回结果
一种经典解决方案是心跳和注册中心模式：
心路广播: Worker 启动后，每隔 N 秒向一个 fanout 交换机发送包含自己IP 的消息 存活判定（TTL）: 注册中心监听该交换机，将收到的IP 和当前时间存入内存字典 自动剔除: 注册中心定期检查字典，如果某个 IP 超过 N*3秒没有更新，则判定该 Worker 已下线 Python中可以基于Kombu和Redis实现：worker.py上报心跳，proxy.py是注册中心（将计算任务代理给worker执行）
import time from kombu import Connection, Exchange def run_worker(): with Connection(&#34;redis://127.0.0.1:6379&#34;) as conn: heartbeat_exchange = Exchange(&#34;worker_discovery&#34;, type=&#34;fanout&#34;) producer = conn.Producer() worker_ip = &#34;127.0.0.1&#34; print(f&#34;[*] Worker {worker_ip} started...&#34;) while True: payload = {&#34;ip&#34;: worker_ip, &#34;ts&#34;: time.time()} producer.publish( payload, exchange=heartbeat_exchange, declare=[heartbeat_exchange], # 不加declare proxy收不到消息 serializer=&#34;json&#34;, ) print(f&#34;[#] Heartbeat sent: {time.ctime()}&#34;) time.sleep (5) if __name__ == &#34;__main__&#34;: run_worker() import time import socket from kombu import Connection, Exchange, Queue def start_proxy(): active_workers = {} timeout_threshold = 15 conn = Connection(&#34;redis://127.0.0.1:6379&#34;) heartbeat_exchange = Exchange(&#34;worker_discovery&#34;, type=&#34;fanout&#34;) # 注意：如果不指定名字 Kombu 会随机生成一个 discovery_queue = Queue(&#34;example&#34;, exchange=heartbeat_exchange, exclusive-True) def process_message(body, message): ip = body.get(&#34;ip&#34;) active_workers[ip] = body.get(&#34;ts&#34;) print(f&#34;[&#43;] Discovered/Updated worker: {ip}&#34;) message.ack() print(&#34;[*] Proxy is listening for heartbeats...&#34;) with conn.Consumer(queues=[discovery_queue], callbacks=[process_message]): last_check = time.time() while True: try: conn.drain_events(timeout=1) except socket.timeout: # 即使没有收到消息也定期检查 worker 存活状态 pass # 每隔 5 秒打印一次当前在线列表 if time.time() - last_check &gt; 5: now = time.time() # 清理超时 Worker dead_workers = [ ip for ip, ts in active workers.items() if now - ts &gt; timeout_threshold ] for ip in dead_workers: del active_workers[ip] print(f&#34;[-] Worker {ip} timed out.&#34;) print(f&#34;Current Online: {list(active_workers.keys())}&#34;) last_check = time.time() if __name__ == &#34;__main__&#34;: try: start_proxy() except KeyboardInterrupt: print(&#34;Exit.&#34;) fanout交换机 Exchange(type=&#34;fanout&#34;)是广播交换机，对应AMQP中topic广播概念，对应《Redis Pub/sub》。广播消息指生产者向topic发一次消息，此时订阅topic的所有消费者都会收到消息。但对于发消息时没订阅topic的消费者，没法收到历史消息。Redis的channel机制和topic一样
...</p>
  </div>
  <footer class="entry-footer"><span title='2026-01-23 21:35:55 +0800 CST'>January 23, 2026</span></footer>
  <a class="entry-link" aria-label="post link to Kombu &#43; Redis的Worker发现" href="https://kyzy540.github.io/post/kombu_redis_heartbeat/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">乱读报告: 2025年11月, 咱还消费低迷吗?
    </h2>
  </header>
  <div class="entry-content">
    <p>2025 年 11 月 24 日，美国银行证券 (BofA Securities) 发布了一篇报告: 《China Consumer（H/A）：Is China still under-consuming? Myth vs. truth》。直译是《中国还消费低迷吗? 臆想vs.真相》
文章是全英文。大致内容是说中国消费近3年确有下行，但并没有特糟。中国市场的特点是消量大，价格低，只看消费额有失偏颇。食品、日用品、电器、骑车等商品在中国的售价显著低于发达国家。处世界前列。医疗、教育等社会保障也可称优秀
另外，作为证券报告，文中还指出中国在文化、体育、娱乐、高端服务等方面还有很大上升空间。还说中国企业当下最好的增长机遇是出海。最后结合前文推荐了几只股票 (泡泡玛特/腾讯/美的/大麦等)
总的来说是典型的市场调研和投资建议报告。投资部分我不关心，市场调研部分还挺有意思
用“量大价低”定义市场，而非只看总金额，角度新颖 文章数据来源于多个权威机构 (联合国粮农组织、世界银行等)，并经过思考整合，有说服力 报告结论大致上跟生活观察吻合，合情合理 想看更多报告翻译的 ，B站上有人做了视频 (也没原文) 美国银行证券解读中国真的在“低消费”吗？迷思与真相
我只想写点我感兴趣的
用&#34;物本位&#34;调整视角 这是报告的最大亮点。核心观点是别看中国人均消费总额低，那是低物价导致的假象。世界工厂的低成本低物价是特殊国情。如果从物本位观察，中国的人均消费实际超过部分发达国家水平
例如，中国的粮食消费高于美国，包括肉、卡路里、蔬菜。同时，中国的粮食、服装、餐饮、交通、水电、网络都比美国低50%以上。人均居住面积比法国和英国大。
生活观察和数字吻合。一线城市的生活质量已不落后发达国家。同样商品国内比日韩便宜得多。餐饮行业冠绝全球。许多去西方一线城市留学生也表示租房比国内昂贵得多
但数字和观察一致就代表真相吗？在我看来不完全是。转换的不是真相，而是视角。“钱本位”视角也很重要。想对齐账还得算钱。如果说中国一年总产值100亿，国内消费20亿。那意味着另外80亿产值必须由出口消化掉。否则就得通缩
所以物本位看，国内消费水平够得上发达国家。但按钱本位看，消费确实低迷。但没完全进入通缩周期
2022-2024我国经济在通缩线上下徘徊 2022年疫情放开后，消费经历了短暂的报复性增长，随后开始下滑。但，是不是逐年递减，已至通缩了呢？是缩了，但没一路下坡
CPI(消费者价格指数)衡量消费品价格变动，2025年12月同比上涨0.8% PPI(生产者价格指数)衡量企业产品价格变动，2025年12月同比下降1.9% “CPI强, PPI弱”意味着消费有需求，但企业商品价格受制于产能或外需，有通缩压力
还不算太糟。国补没白贴
企业内卷和出海谋生 报告提供的出路是企业应积极开展出口贸易
中国是世界工厂，有独特的成本优势。同时也指出相同产品在国内售价低廉。对消费者来说是好事，商品物美价廉。但对企业来说很惨，市场竞争激烈，成本上涨，却难以提高售价
企业利润降低，裁员。消费者愈发谨慎消费，对售价更加敏感。这也符合生活观察
出海是企业谋求更高利润的机会。很多国货即使抬高价格，到海外依然有很强竞争力。所幸很多企业有远见，很早就采取行动，甚至已经收获一定成果。TODO: 2025第三季度我国出口上涨6.6%，该成绩令国内外都感到惊喜
这也和生活观察吻合。世博会期间去日本，杨国福麻辣烫一碗卖60多门口还排大队
游戏行业也是。从《原神》到《黑猴》，到2025年的《鸣潮》、《烟云十六声》，国产游戏不缺国际市场名利双收的案例
还有泡泡玛特的拉布布，开到纽约的雪王，去日本竞争k-car的比亚迪，等等
就写这么多吧。读市场调研报告很有趣。数字对照生活，看得才真切。澡堂子里人人都是经济学家，风言风语，扑朔迷离。当有些印象被反复提及，总会让人纳闷，是已经达成了广泛认同，还是仅仅是谣言传播效果好？其中又有哪些是被夸大的？还是得拿数字照一照，比较明了
</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-20 21:15:38 +0800 CST'>December 20, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 乱读报告: 2025年11月, 咱还消费低迷吗?" href="https://kyzy540.github.io/post/2025_consuming_report/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">《黑猫侦探: 深入本质》
    </h2>
  </header>
  <div class="entry-content">
    <p>
典型的Telltale式玩法，典型的黑色侦探故事。《黑猫侦探》很好地诠释了“经典手段”不过时，只要运用得当，就能令人满意
《黑》的最大亮点是故事。有人说，讲好一个故事最重要的是“层次感”。《黑》典范式地演绎了这个观点多么正确。以命案引入，调查过程中遇到形形色色的人，各怀鬼胎，又相互关联。侦探抽丝剥茧，逐步揭示每个人不可靠人的秘密。随着故事进展，这些看似不相关的秘密慢慢关联，引向背后更大谜团的真相
我也读过雷蒙德·钱德勒，读过猎魔人的短篇。叙事技巧同样秉承此脉，同样精彩 —— Noire不过时。虽然面貌不同，但相同的内核依然能俘获人心
《黑》中还有一个桥段，专门调侃了黑色侦探小说 (Noire fiction)。有种打破第四面墙的趣味
动物化的人物形象也很契合黑色侦探。可以脸谱化人物性格，也可以合理化一些“特技”。例如主角黑猫感官敏感，行动敏捷，符合猫的特质。他时常遇上倒霉事儿，又总能化险为夷。也能贴合“黑猫”的传闻传说。还有猫有九条命，等等。
刻板形象是黑色侦探的特色，但那只是引子。“深入本质”才是有趣的部分。故事中重要角色都有层次，侦探必须一次次的小调查，找出他们内心隐藏的秘密。这些秘密有些明显和最核心的命案有关，有些则看似关系不大。但最后，当秘密越集越全，真相的大拼图也有自然而然在玩家心中浮现。灵光一现的愉悦
当然，这游戏不火也该着，优化着实拉垮。2020年的技术做走路模拟还掉帧，降画质也没用，真是没谁了。特别是前2个场景，明显是制作组不自量力，把控不了“大场景”。到后面场景规模缩小，甚至只留QTE的时候就顺畅多了
也因为这蹩脚的体验，我玩儿的时候也在不断思考，既然玩儿的就是故事，又是单分支，何苦一定要做成游戏呢？
漫画？肯定行，毕竟源自漫画。但有没可能IP方就是想拓宽影响力呢？而且游戏中有一些直接引用了漫画的桥段，设计的非常高明。能“动”的漫画确实比传统漫画更带劲
那电影或剧集呢？这故事的节奏其实偏慢，也没有什么大场面，不见得卖相好。而且这年头想做出高质量动画剧集，成本一定比小规模游戏低 —— 毕竟这游戏卡通渲染，不用动捕，不用脸模，甚至没啥大场景。建模也很有一种老好莱坞式的一鱼多吃的复用率。成本应该可控
而且游戏的带入感是其他媒体无法比拟的。玩儿的过程中我也有卡关看攻略的时候，那会儿就会寻思，要不云通关得了。但看了一小会儿就觉得不对劲，缺乏代入感。看着自己手头的剧本被别人以他的方式演绎，总觉得不自在
总之案子嘛，还得自己破才好
</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-13 17:01:10 +0800 CST'>December 13, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 《黑猫侦探: 深入本质》" href="https://kyzy540.github.io/post/blacksad_under_the_skin/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">如何中断Taskflow工作流
    </h2>
  </header>
  <div class="entry-content">
    <p>taskflow的poster&#43;conductor架构下，conductor以多线程并发运行job。线程池被封装在内部。因此一旦conductor开始执行任务，想中断它就很麻烦。通常要重启整个conductor线程池
是否有更优雅的办法中断conductor正在执行的任务？
不可行——JobBoard.abandon()/trash() JobBoard的abandon和trash方法不能终止job。前者只删除job.lock，后者会把job数据拷贝到/taskflow/.trash/下再删除job node。二者都没解决核心问题: 阻止工作流继续执行下一步骤。
不推荐——修改数据库atomdetails状态 设想: 修改taskflow persistence数据库(如postresql) flowdetails和atomdetails表。把RUNNING和PENDING的步骤都UPDATE成REVERTED。期望工作流在进入下一个task时会异常自动中断
测试结果: taskflow会检查任务状态 合法性。一个步骤SUCCESS，但后续步骤状态是FAILURE或REVERTED会被识别为状态非法。这会导致conductor异常退出，影响其他线程。此外，taskflow会将失败任务的failure字段转换成dict。写入的数据结构必须也合法，否则任务无法被重试
同理state设为REVERT_FAILURE或SUCCESS可以中断工作流，但也会报错状态非法
总之方案可行，但不高效
可行——kill conductor进程 每个conductor都只维护一个线程，在更上层用 进程 维护多个conductor。这样就可通过kill conductor进程。但代价是任务的revert方法不会被执行。如果所有任务完全幂等，没有资源泄漏风险，是可行的
但不推荐这个方案。它实际上提高了任务设计难度，也不符合taskflow的设计理念
推荐——execute()装饰器 示例代码如下
from threading import Event from taskflow import task cancel_event = Event() class CancelableTask(task.Task): def __init_subclass__(cls, **kwargs): super().__init_subclass__(**kwargs) if hasattr(cls, &#34;execute&#34;) and callable(cls.execute): original_execute = cls.execute def wrapped_execute(self, *args, **kwargs): if cancel_event and cancel_event.is_set(): raise Exception(&#34;Flow cancelled at start&#34;) result = original_execute(self, *args, **kwargs) if cancel_event and cancel_event.is_set(): raise Exception(&#34;Flow cancelled after execution&#34;) return result cls.execute = wrapped_execute class DownloadTask(CancelableTask): def execute(self, url, **kwargs): print(f&#34;Downloading {url}...&#34;) for i in range(10): print(f&#34;Progress: {i*10}%&#34;) return f&#34;Downloaded {url}&#34; def revert(self, result, *args, **kwargs): pass # TODO 清理工作 __init_subclass__是Python 3.6引入的特性，在子类初始化时执行。赋予父类修改子类方法的能力。示例代码中，DownloadTask继承了CancelableTask，它的execute方法被 透明 地封装了一层装饰器。如果检测到cancel_event会抛出异常。这种抛异常方式是taskflow可以处理的，DownloadTask的revert方法随后会被调用，完成清理工作
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-03 16:55:28 +0800 CST'>December 3, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 如何中断Taskflow工作流" href="https://kyzy540.github.io/post/taskflow_stop_a_flow/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Taskflow自定义Conductor
    </h2>
  </header>
  <div class="entry-content">
    <p>Taskflow原生的 blocking/nonblocking Conductor不支持Job过滤，也就是无差别消费所有Job。如果要实现特殊Job特殊Conductor处理，需要自定义Conductor
什么Job算特殊？例如有某个工作流需要GPU资源，而Conductor集群里只有个别机器有GPU。此时最好的调度策略是有GPU的机器运行GPU Job。如果GPU机器空闲且其他机器忙，也可以运行不需要GPU的Job
过滤Job Conductor重载_can_claim_more_jobs即可过滤Job。下面代码的has_gpu没实现，仅用于说明逻辑: 无GPU的机器不会执行需要GPU的Job；有GPU的机器会执行所有Job
from taskflow.conductors.backends.impl_nonblocking import NonBlockingConductor class GpuConductor(NonBlockingConductor): def has_gpu(self): pass # TODO 获取GPU状态 def _can_claim_more_jobs(self, job): if not super()._can_claim_more_jobs(job): return False gpu = job.details.get(&#34;gpu&#34;) if gpu and not self.has_gpu(): return False return True stevedore Taskflow实例化Conductor依赖 stevedore.driver.DriverManager，其基于命名空间和entry point在运行时加载Conductor。因此GpuConductor必须添加到taskflow.conductors命名空间下。推荐写pyproject.toml
[project.entry-points.&#34;taskflow.conductors&#34;] gpu = &#34;custom_conductor.gpu_conductor:GpuConductor&#34; 编辑安装包
pip install -e . 注意，必须安装后stevedore才能在环境的分发元数据里发现新的entry point。直接跑源代码而不安装，stevedore看不到
安装验证
from stevedore.extension import ExtensionManager em = ExtensionManager(&#34;taskflow.conductors&#34;) print([e.name for e in em.extensions]) # 应包含 &#34;gpu&#34; 注册entry point不影响修改源代码，即修改GpuConductor代码不需要重新安装
Job post 发布Job时，需要指定details
job_backend = job_backends.fetch(name, conf, persistence=persist_backend) details = {&#34;gpu&#34;: True} job_backend.post(flow_name, logbook, details) 补充 额外补充，Conductor提供的notifier callback接口不能用于过滤job。用法类似conductor.notifier.register(cond.notifier.ANY, callback)。关键在于callback不能中断运行job的流程。notifier既不返回值，也不出异常。核心代码如下
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-03 13:44:42 +0800 CST'>December 3, 2025</span></footer>
  <a class="entry-link" aria-label="post link to Taskflow自定义Conductor" href="https://kyzy540.github.io/post/taskflow_inherit_conductor/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">《中国式相亲》
    </h2>
  </header>
  <div class="entry-content">
    <p>用预期外的方式传递了预期外的乐趣
核心玩法是卡牌构筑。模拟经营……弱到可以忽略不计，就是个对对碰。玩法没有模拟现实中相亲的过程，失望。不像《中国式家长》，用量化方式模拟教育子女确实很有生活味儿
恋爱部分更差。女主角都是日漫女主的本地化版本，反正我生活中没那样的人，爱不起来
但支线都做的不错，量大，贴近生活。有很多2025年的网络梗，ROG Ally, Steamdeck等。这些内容很接地气。这是所谓的预期外乐趣
“中国式”是个很重的标签。贴上它意味着玩家一定期待体验特别本土化的内容。加上《家长》的成功，玩家肯定想在游戏中体验 中国特色相亲 过程的。得有三姑六婆做媒吧，得有家长催婚吧，得遇到“奇葩”吧，得有问车问房当面冒犯的桥段吧。至少我是这么期望的
很可惜，我期望的内容主线里都没有。但意外地支线里找补回来了。玩家会作为旁观者，掺和进邻里间家长里短的小故事中。很有生活气息，不错。任务中还塞了不少2025热门网络梗，趁新鲜劲儿玩到也饶有趣味
其实游戏改叫《居委会大妈模拟》更合适。卡牌玩法表现的是广义的“说服”，跟会所拉客完全可以拆分开。会所经营做成小游戏得了。虽然标题没那么博眼球，但实事求是
我不负责地猜测，主创团队可能起初是想把卡牌构筑揉进相亲博弈的玩法中，但没成功。你想，一男一女面对面一坐，像不像卡牌对战？你问我工资，我评你相貌，像不像出牌博弈？入座前的背景调查能不能通过构筑来抽象？而且相亲结尾和打牌一样，不成容易急眼。最后，还可以像《昆特牌:王权陨落》那样，在特殊关卡加特殊卡牌，以结合剧情表达
当然以上都是我胡思乱想。说回实际游戏。支线剧情轻松有趣，主线和核心玩法却比较容易腻。赶上打折，花30多元玩10小时左右还是物超所值的
</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-27 08:57:20 +0800 CST'>November 27, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 《中国式相亲》" href="https://kyzy540.github.io/post/matchmaking_inc/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">大鹏的《长安的荔枝》
    </h2>
  </header>
  <div class="entry-content">
    <p>
改编了，改得好！大鹏厉害啊，一人担当编剧、导演和主演。
演员阵容沿用《年会不能停》白客和庄达菲组合，好评。影片中人物性格和原著不同，明显经过量身定制。特别贴合演员舒适区，还不违背原著核心，见功夫。右相和公公的戏份也很出彩，给已脍炙人口的故事增添了新维度，新解读，新亮点。总之，情节调整后，更适合大荧幕。我看前一大好奇就是小说那么温吞，照搬成电影会不会无趣。看完感觉很棒，张力足
回想起来，大鹏从屌丝男士到今天，每一步都走得很扎实。每次在商业和口碑上都进步一点。每部作品都有上一部的影子，但又有所突破
对了，片尾曲很棒。词曲都厉害，跟《菊花台》有一拼
</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-24 12:11:20 +0800 CST'>November 24, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 大鹏的《长安的荔枝》" href="https://kyzy540.github.io/post/the_lychee_road/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">《开刃》
    </h2>
  </header>
  <div class="entry-content">
    <p>
依旧是K.J.帕克，依旧愉快的阅读体验。这次是居然是个跑团故事。大厦将倾，5个人临危受命，踏上旅程。同时在他们不知道的世界角落，还有暗流涌动……
这是书背后简介给我的期待，但实际读完故事不复杂。别看字数不少，大部分内容都是角色间斗嘴，闲言碎语。跳着读，几页几页就翻过去了。故事架构扁平，没有围城三部曲 (《城防三十六计》) 中的起伏惊喜，也没有故事背后朦胧又宏大的世界观
他老人家小说都很有史诗感，且往往通过作品中人物口述得来。他擅长写日常生活，不同阶级、不同阵营、不同信仰人的生活。由这些人物生活中的言谈，不同视角，拼凑出纷繁复杂的世界观。这也能看出帕克的史观: 历史有大势所趋的部分，但大变革中往往也由诸多偶然事件促成
于是我不禁疑惑，帕克老爷子是有意想写个跑团故事呢，还是中途发现絮叨话写多了，收不住，最后凑合而成?
根据豆瓣数据，汤姆·霍尔特是90年代开始以K.J.帕克笔名出版奇幻小说。前期都是短篇，第一部长篇是1998年的《钢之色》，也就是法庭剑斗三部曲的开篇
显然，三部曲的后两本失控了，结尾一塌糊涂。作者应该也意识到这一点
到2019年的《城防三十六计》，是围城三部曲开头。三本书实际上是3个独立故事，篇幅中等，仅共享背景世界观。读者以任意顺序读3本书都没问题。作品质量极高，要我说可以和乔治.R.R马丁和安杰伊.萨普科夫斯基齐名
显然，中短篇是K.J.帕克的舒适区
而说回《开刃》，是2012年的作品。夹在两个三部曲中间
我猜也许它是帕克创作道路上的中间态，是试探过程的一块里程碑。不算完美，但回头一看，还不赖
</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-17 08:59:56 +0800 CST'>November 17, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 《开刃》" href="https://kyzy540.github.io/post/sharps/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Siri接大模型唠嗑
    </h2>
  </header>
  <div class="entry-content">
    <p>简介 创建一个快捷指令供Siri使用。快捷指令会循环听用户问题，通过API发给大模型，后朗读回答。可以多轮问答，包含上下文
API使用阿里云，可以改成其他兼容OpenAI标准的
必须提供API Key。不免费
用法 下载快捷指令: 唠嗑
将Bearer sk-xxx替换成有效的 API Key 就可以使用了。获取key方法参考官方文档
DeepSeek Moonshot AI (Kimi) 阿里云 以下参数可以按需调整
model_name: 模型名，默认qwen-flash。用 DeepSeek API 改成 deepseek-chat URL: 兼容OpenAI API标准的base_url。DeepSeek是https://api.deepseek.com 重复3次: 控制问答轮次，默认最多3轮。控制轮次是为了节约Token。由于问答包含上下文，轮次越多携带上下文越多，Token消耗越多 enable_search: True: 允许模型推理过程中联网，默认开启。模型更好回答时效性问题。代价是会多消耗些许Token prompt Answer briefly, under 40 words: 提示词。限制回答字数。提示词也算Token，其本身不建议写长 费用 价格请以服务商官网实时报价为准。这里介绍算法。以2025-11-12阿里云qwen-flash报价为例
单次请求的输入Token数 输入单价（每千Token） 输出单价（每千Token） 0&lt;Token≤128K 0.00015元 0.00015元 128K&lt;Token≤256K 0.0006元 0.006元 256K&lt;Token≤1M 0.0012元 0.012元 1个Token通常对应一个汉字，或一个英语单词。看起来不贵，但实际计费不仅按问题的字数算，还有提示词、搜索网络等其他计费项
如果觉得不好算，实践更直观。为了确保不少算，我把提示词限制升到80: Answer briefly, under 80 words
3轮问答消耗消耗11K Tokens。输出10.5K, 输入0.5K。请求Token数匹配最低档位，花费 0.0015 * 10.5 &#43; 0.00015 * 0.5 = 0.015825元
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-12 10:58:24 +0800 CST'>November 12, 2025</span></footer>
  <a class="entry-link" aria-label="post link to Siri接大模型唠嗑" href="https://kyzy540.github.io/post/ios_shortcut_chatai/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://kyzy540.github.io/post/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://kyzy540.github.io/">低质量随笔</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
