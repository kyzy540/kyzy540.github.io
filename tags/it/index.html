<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>It | 低质量随笔</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://kyzy540.github.io/tags/it/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5c0f21e25c3551fd5c4685517c592eb41f5073118ce154d59fa4fd79f71c15c3.css" integrity="sha256-XA8h4lw1Uf1cRoVRfFkutB9QcxGM4VTVn6T9efccFcM=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kyzy540.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://kyzy540.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kyzy540.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://kyzy540.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://kyzy540.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://kyzy540.github.io/tags/it/index.xml">
<link rel="alternate" hreflang="en" href="https://kyzy540.github.io/tags/it/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://kyzy540.github.io/tags/it/">
  <meta property="og:site_name" content="低质量随笔">
  <meta property="og:title" content="It">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="It">
<meta name="twitter:description" content="">

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kyzy540.github.io/" accesskey="h" title="低质量随笔 (Alt + H)">低质量随笔</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://kyzy540.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://kyzy540.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://kyzy540.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    It
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Kombu &#43; Redis的Worker发现
    </h2>
  </header>
  <div class="entry-content">
    <p>分布式系统中，发现远端worker是一种常见需求。例如：一个计算任务需要GPU，而集群中只有少数机器配备。常见思路是让 管控/调度服务 发现GPU机部（worker），并把计算任务代理给worker执行，接收返回结果
一种经典解决方案是心跳和注册中心模式：
心路广播: Worker 启动后，每隔 N 秒向一个 fanout 交换机发送包含自己IP 的消息 存活判定（TTL）: 注册中心监听该交换机，将收到的IP 和当前时间存入内存字典 自动剔除: 注册中心定期检查字典，如果某个 IP 超过 N*3秒没有更新，则判定该 Worker 已下线 Python中可以基于Kombu和Redis实现：worker.py上报心跳，proxy.py是注册中心（将计算任务代理给worker执行）
import time from kombu import Connection, Exchange def run_worker(): with Connection(&#34;redis://127.0.0.1:6379&#34;) as conn: heartbeat_exchange = Exchange(&#34;worker_discovery&#34;, type=&#34;fanout&#34;) producer = conn.Producer() worker_ip = &#34;127.0.0.1&#34; print(f&#34;[*] Worker {worker_ip} started...&#34;) while True: payload = {&#34;ip&#34;: worker_ip, &#34;ts&#34;: time.time()} producer.publish( payload, exchange=heartbeat_exchange, declare=[heartbeat_exchange], # 不加declare proxy收不到消息 serializer=&#34;json&#34;, ) print(f&#34;[#] Heartbeat sent: {time.ctime()}&#34;) time.sleep (5) if __name__ == &#34;__main__&#34;: run_worker() import time import socket from kombu import Connection, Exchange, Queue def start_proxy(): active_workers = {} timeout_threshold = 15 conn = Connection(&#34;redis://127.0.0.1:6379&#34;) heartbeat_exchange = Exchange(&#34;worker_discovery&#34;, type=&#34;fanout&#34;) # 注意：如果不指定名字 Kombu 会随机生成一个 discovery_queue = Queue(&#34;example&#34;, exchange=heartbeat_exchange, exclusive-True) def process_message(body, message): ip = body.get(&#34;ip&#34;) active_workers[ip] = body.get(&#34;ts&#34;) print(f&#34;[&#43;] Discovered/Updated worker: {ip}&#34;) message.ack() print(&#34;[*] Proxy is listening for heartbeats...&#34;) with conn.Consumer(queues=[discovery_queue], callbacks=[process_message]): last_check = time.time() while True: try: conn.drain_events(timeout=1) except socket.timeout: # 即使没有收到消息也定期检查 worker 存活状态 pass # 每隔 5 秒打印一次当前在线列表 if time.time() - last_check &gt; 5: now = time.time() # 清理超时 Worker dead_workers = [ ip for ip, ts in active workers.items() if now - ts &gt; timeout_threshold ] for ip in dead_workers: del active_workers[ip] print(f&#34;[-] Worker {ip} timed out.&#34;) print(f&#34;Current Online: {list(active_workers.keys())}&#34;) last_check = time.time() if __name__ == &#34;__main__&#34;: try: start_proxy() except KeyboardInterrupt: print(&#34;Exit.&#34;) fanout交换机 Exchange(type=&#34;fanout&#34;)是广播交换机，对应AMOP中topic广播概念，对应《Redis Pub/sub》。广播消息指生产者向topic发一次消息，此时订阅topic的所有消费者都会收到消息。但对于发消息时没订阅topic的消费者，没法收到历史消息。Redis的channel机制和topic一样
...</p>
  </div>
  <footer class="entry-footer"><span title='2026-01-23 21:35:55 +0800 CST'>January 23, 2026</span></footer>
  <a class="entry-link" aria-label="post link to Kombu &#43; Redis的Worker发现" href="https://kyzy540.github.io/post/kombu_redis_heartbeat/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">如何中断Taskflow工作流
    </h2>
  </header>
  <div class="entry-content">
    <p>taskflow的poster&#43;conductor架构下，conductor以多线程并发运行job。线程池被封装在内部。因此一旦conductor开始执行任务，想中断它就很麻烦。通常要重启整个conductor线程池
是否有更优雅的办法中断conductor正在执行的任务？
不可行——JobBoard.abandon()/trash() JobBoard的abandon和trash方法不能终止job。前者只删除job.lock，后者会把job数据拷贝到/taskflow/.trash/下再删除job node。二者都没解决核心问题: 阻止工作流继续执行下一步骤。
不推荐——修改数据库atomdetails状态 设想: 修改taskflow persistence数据库(如postresql) flowdetails和atomdetails表。把RUNNING和PENDING的步骤都UPDATE成REVERTED。期望工作流在进入下一个task时会异常自动中断
测试结果: taskflow会检查任务状态 合法性。一个步骤SUCCESS，但后续步骤状态是FAILURE或REVERTED会被识别为状态非法。这会导致conductor异常退出，影响其他线程。此外，taskflow会将失败任务的failure字段转换成dict。写入的数据结构必须也合法，否则任务无法被重试
同理state设为REVERT_FAILURE或SUCCESS可以中断工作流，但也会报错状态非法
总之方案可行，但不高效
可行——kill conductor进程 每个conductor都只维护一个线程，在更上层用 进程 维护多个conductor。这样就可通过kill conductor进程。但代价是任务的revert方法不会被执行。如果所有任务完全幂等，没有资源泄漏风险，是可行的
但不推荐这个方案。它实际上提高了任务设计难度，也不符合taskflow的设计理念
推荐——execute()装饰器 示例代码如下
from threading import Event from taskflow import task cancel_event = Event() class CancelableTask(task.Task): def __init_subclass__(cls, **kwargs): super().__init_subclass__(**kwargs) if hasattr(cls, &#34;execute&#34;) and callable(cls.execute): original_execute = cls.execute def wrapped_execute(self, *args, **kwargs): if cancel_event and cancel_event.is_set(): raise Exception(&#34;Flow cancelled at start&#34;) result = original_execute(self, *args, **kwargs) if cancel_event and cancel_event.is_set(): raise Exception(&#34;Flow cancelled after execution&#34;) return result cls.execute = wrapped_execute class DownloadTask(CancelableTask): def execute(self, url, **kwargs): print(f&#34;Downloading {url}...&#34;) for i in range(10): print(f&#34;Progress: {i*10}%&#34;) return f&#34;Downloaded {url}&#34; def revert(self, result, *args, **kwargs): pass # TODO 清理工作 __init_subclass__是Python 3.6引入的特性，在子类初始化时执行。赋予父类修改子类方法的能力。示例代码中，DownloadTask继承了CancelableTask，它的execute方法被 透明 地封装了一层装饰器。如果检测到cancel_event会抛出异常。这种抛异常方式是taskflow可以处理的，DownloadTask的revert方法随后会被调用，完成清理工作
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-03 16:55:28 +0800 CST'>December 3, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 如何中断Taskflow工作流" href="https://kyzy540.github.io/post/taskflow_stop_a_flow/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Taskflow自定义Conductor
    </h2>
  </header>
  <div class="entry-content">
    <p>Taskflow原生的 blocking/nonblocking Conductor不支持Job过滤，也就是无差别消费所有Job。如果要实现特殊Job特殊Conductor处理，需要自定义Conductor
什么Job算特殊？例如有某个工作流需要GPU资源，而Conductor集群里只有个别机器有GPU。此时最好的调度策略是有GPU的机器运行GPU Job。如果GPU机器空闲且其他机器忙，也可以运行不需要GPU的Job
过滤Job Conductor重载_can_claim_more_jobs即可过滤Job。下面代码的has_gpu没实现，仅用于说明逻辑: 无GPU的机器不会执行需要GPU的Job；有GPU的机器会执行所有Job
from taskflow.conductors.backends.impl_nonblocking import NonBlockingConductor class GpuConductor(NonBlockingConductor): def has_gpu(self): pass # TODO 获取GPU状态 def _can_claim_more_jobs(self, job): if not super()._can_claim_more_jobs(job): return False gpu = job.details.get(&#34;gpu&#34;) if gpu and not self.has_gpu(): return False return True stevedore Taskflow实例化Conductor依赖 stevedore.driver.DriverManager，其基于命名空间和entry point在运行时加载Conductor。因此GpuConductor必须添加到taskflow.conductors命名空间下。推荐写pyproject.toml
[project.entry-points.&#34;taskflow.conductors&#34;] gpu = &#34;custom_conductor.gpu_conductor:GpuConductor&#34; 编辑安装包
pip install -e . 注意，必须安装后stevedore才能在环境的分发元数据里发现新的entry point。直接跑源代码而不安装，stevedore看不到
安装验证
from stevedore.extension import ExtensionManager em = ExtensionManager(&#34;taskflow.conductors&#34;) print([e.name for e in em.extensions]) # 应包含 &#34;gpu&#34; 注册entry point不影响修改源代码，即修改GpuConductor代码不需要重新安装
Job post 发布Job时，需要指定details
job_backend = job_backends.fetch(name, conf, persistence=persist_backend) details = {&#34;gpu&#34;: True} job_backend.post(flow_name, logbook, details) 补充 额外补充，Conductor提供的notifier callback接口不能用于过滤job。用法类似conductor.notifier.register(cond.notifier.ANY, callback)。关键在于callback不能中断运行job的流程。notifier既不返回值，也不出异常。核心代码如下
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-12-03 13:44:42 +0800 CST'>December 3, 2025</span></footer>
  <a class="entry-link" aria-label="post link to Taskflow自定义Conductor" href="https://kyzy540.github.io/post/taskflow_inherit_conductor/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Siri接大模型唠嗑
    </h2>
  </header>
  <div class="entry-content">
    <p>简介 创建一个快捷指令供Siri使用。快捷指令会循环听用户问题，通过API发给大模型，后朗读回答。可以多轮问答，包含上下文
API使用阿里云，可以改成其他兼容OpenAI标准的
必须提供API Key。不免费
用法 下载快捷指令: 唠嗑
将Bearer sk-xxx替换成有效的 API Key 就可以使用了。获取key方法参考官方文档
DeepSeek Moonshot AI (Kimi) 阿里云 以下参数可以按需调整
model_name: 模型名，默认qwen-flash。用 DeepSeek API 改成 deepseek-chat URL: 兼容OpenAI API标准的base_url。DeepSeek是https://api.deepseek.com 重复3次: 控制问答轮次，默认最多3轮。控制轮次是为了节约Token。由于问答包含上下文，轮次越多携带上下文越多，Token消耗越多 enable_search: True: 允许模型推理过程中联网，默认开启。模型更好回答时效性问题。代价是会多消耗些许Token prompt Answer briefly, under 40 words: 提示词。限制回答字数。提示词也算Token，其本身不建议写长 费用 价格请以服务商官网实时报价为准。这里介绍算法。以2025-11-12阿里云qwen-flash报价为例
单次请求的输入Token数 输入单价（每千Token） 输出单价（每千Token） 0&lt;Token≤128K 0.00015元 0.00015元 128K&lt;Token≤256K 0.0006元 0.006元 256K&lt;Token≤1M 0.0012元 0.012元 1个Token通常对应一个汉字，或一个英语单词。看起来不贵，但实际计费不仅按问题的字数算，还有提示词、搜索网络等其他计费项
如果觉得不好算，实践更直观。为了确保不少算，我把提示词限制升到80: Answer briefly, under 80 words
3轮问答消耗消耗11K Tokens。输出10.5K, 输入0.5K。请求Token数匹配最低档位，花费 0.0015 * 10.5 &#43; 0.00015 * 0.5 = 0.015825元
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-12 10:58:24 +0800 CST'>November 12, 2025</span></footer>
  <a class="entry-link" aria-label="post link to Siri接大模型唠嗑" href="https://kyzy540.github.io/post/ios_shortcut_chatai/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">删除ROG奥创中心手柄映射配置
    </h2>
  </header>
  <div class="entry-content">
    <p>ROG的奥创中心可以为每个游戏设独立的键位映射，但有个缺陷: 每个游戏的映射都会被保存下来，罗列在映射模版列表里。该如何删除自定义映射模版?
先找到模版文件目录
C:\Users\MyName\AppData\Local\Packages\B9ECED6F.ArmouryCrateSE_qmba6cd70vzyy\LocalState\GamepadCustomize 其中MyName是本地用户名。B9ECED6F.ArmouryCrateSE_qmba6cd70vzyy前后两串码我不确定是否随机，反正中间ArmouryCrateSE是一定的
目录的Profiles和Templates里有若干&lt;uuid&gt;.json文件，里面包含了模版名。删除json文件即可
注意，模版文件一式两份，两个目录下都要删除
</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-01 21:44:47 +0800 CST'>November 1, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 删除ROG奥创中心手柄映射配置" href="https://kyzy540.github.io/post/rog_armory_crate_template/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mermaid图展示Python类方法重载
    </h2>
  </header>
  <div class="entry-content">
    <p>class GrandParent: @classmethod def show(cls): print(&#34;GrandParent show&#34;) cls.age() @classmethod def age(cls): print(&#34;Age: 60&#34;) class Parent(GrandParent): @classmethod def show(cls): print(&#34;Parent show&#34;) super().show() @classmethod def age(cls): print(&#34;Age: 40&#34;) class Child(Parent): @classmethod def show(cls): print(&#34;Child show&#34;) super().show() @classmethod def age(cls): print(&#34;Age: 20&#34;) if __name__ == &#34;__main__&#34;: Child.show() 上面的python代码输出
Child show Parent show GrandParent show Age: 20 解释一下。虽然在 GrandParent.show() 中调用的是 cls.age()，但由于是在 Child 上下文中执行，所以实际调用的是 Child.age()，因此最终输出的是 “Age: 20” 而不是 “Age: 60”
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-01 10:51:28 +0800 CST'>November 1, 2025</span></footer>
  <a class="entry-link" aria-label="post link to Mermaid图展示Python类方法重载" href="https://kyzy540.github.io/post/python_overload_mermaid/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">iTerm2 &#43; Ollama启用AI功能
    </h2>
  </header>
  <div class="entry-content">
    <p>iTerm2 3.5后提供了AI功能，有2种用法:
Command &#43; Shift &#43; .打开composer，输入自然语言后Command &#43; y生成shell命令 Command &#43; Shift &#43; y打开AI chat，关联iterm2 session作为上下文，和大模型问答 自然语言生成shell命令挺方便，不用去浏览器打开大模型网站，提问、复制、粘贴。安装步骤不复杂，参考文章:
《Maximize Productivity with iTerm2 AI Features with Ollama 100% free》
也有别家文章介绍iTerm2 AI其他配法，例如输入API Key远程调用Dashscope。但我推荐Ollama，重点是数据安全
Ollama是开源软件，本地运行大模型，数据不会上传云端 Ollama支持多个大模型，如llama、qwen、deepseek等，可自行选择 除下载模型外，不依赖互联网 100%免费 当然，Ollama也非完美，有些功能没法用，例如AI Completion也就是命令自动补全。但我毕竟最优先考虑数据安全和免费，功能缺点也就凑合了。退一步想，如果生成shell命令足够快，自动补没有也罢
说完有的没的，聊具体安装。我基于上面博文做了些调整
用brew安装iTerm2 AI Plugin和ollama更方便
brew install --cask itermai brew install ollama # 开机自启动 brew services start ollama Configure AI Models Manually 重点配置和文章一样，区别是模型选deepseek-coder:1.7b
API: Llama
API URL: http://localhost:11434/api/chat
Model: deepseek-coder:1.7b
我测试了几个模型: qwen2.5:3b/codellama:7b/qwen2.5-coder:1.5b/qwen3:4b/deepseek-r1:1.5b/deepseek-coder:1.7b。 deepseek-coder:1.7b 最好用。生成命令一般5秒左右，慢也不超过10秒。如上所说，快才好使，不然就开浏览器得了
次优选是 qwen2.5-coder:1.5b，10~20秒生成命令。deepseek-r1和qwen3默认启用thinking，耗时超过1分钟，iTerm2会超时报错 (我没找到禁用thinking的方法，也许禁用后性能会不一样)
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-28 17:36:04 +0800 CST'>October 28, 2025</span></footer>
  <a class="entry-link" aria-label="post link to iTerm2 &#43; Ollama启用AI功能" href="https://kyzy540.github.io/post/iterm2_ai_plugin/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">pyenv迁移uv
    </h2>
  </header>
  <div class="entry-content">
    <p>pyenv和uv是俩python工具，都可以管理版本。只不过后者还提供管理项目的功能。看他们github介绍可见一斑
pyenv
Simple Python version management
uv
An extremely fast Python package and project manager, written in Rust.
uv所谓的项目管理，包含构建、测试、发布等功能。传统软件工程的老几样。显然管辖范围比pyenv大。在uv之前python的项目管理工具还有poetry、pdm等。综合比较项目活跃度、易用性、性能后，uv是其中较好的一款工具
关于项目管理不展开说，仅介绍如何从pyenv迁移到uv。这对开发者来说通常是绕不开的第一步
如果有耐心，可以先看uv官方文档。下面是实操
安装uv，在macos下用brew brew install uv 进入项目目录，初始化项目 uv init 此时，uv会创建.python-version、main.py、pyproject.toml等文件，和.venv目录，对应未初始化的虚拟环境。对于已有项目的迁移，程序入口和 Python 版本通常已经明确，可以保留 pyproject.toml 和 .venv，其余删除
编辑pyproject.toml，指定python版本和pyenv一致
导入依赖包
uv add -r requirements.txt 虽然导依赖只有一行命令，但它其实做了3件事: 用指定python版本真正初始化.venv虚拟环境 -&gt; 修改pyproject.toml文件添加依赖 -&gt; 安装依赖包。如果第一次运行且依赖多。这里可能会多花些时间
顺带一提，uv是多线程装包，速度比pyenv&#43;pip快得多
删除pyenv初始化配置，通常在.zshrc等地方。记得 重启shell。否则source .venv/bin/activate可能会失效。这也是我放弃pyenv的原因之一。它可能引入冲突，难以排查 #eval &#34;$(pyenv init -)&#34; #eval &#34;$(pyenv virtualenv-init -)&#34; 到这其实迁移已完成。为了方便，可以加点佐料
7. 安装direnv
brew install direnv 8. 启用direnv和python的oh-my-zsh插件
# vi ~/.zshrc plugins=(... python direnv) PYTHON_VENV_NAME=&#34;.venv&#34; PYTHON_AUTO_VRUN=true source $ZSH/oh-my-zsh.sh direnv方便自动设环境变量 (如PYTHONPATH)，写在.envrc里即可。python插件可以自动启用/退出虚拟环境，注意PYTHON_VENV_NAME和PYTHON_AUTO_VRUN，必须在source $ZSH/oh-my-zsh.sh前声明
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-05-15 13:48:54 +0800 CST'>May 15, 2025</span></footer>
  <a class="entry-link" aria-label="post link to pyenv迁移uv" href="https://kyzy540.github.io/post/pyenv_to_uv/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">brew 降级
    </h2>
  </header>
  <div class="entry-content">
    <p>参考: Homebrew install specific version of formula?
以alt-tab为例，从7.20.0 (有bug会崩溃) 降级到7.19.1
打开 https://formulae.brew.sh/cask/alt-tab 跳转 Cask code on GitHub 点开 alt-tab.rb History 找到要目标版本 (要降低到的版本)，点View code at this point 下载 alt-tab.rb 7.19.1 控制台进alt-tab.rb所在目录，执行brew rnstall alt-tab.rb 该方法虽然麻烦，但通用。如果软件预备了多版本，例如 mysql-client，可以通过brew install mysql-client@8.4切版本，相对方便
</p>
  </div>
  <footer class="entry-footer"><span title='2025-02-20 14:05:23 +0800 CST'>February 20, 2025</span></footer>
  <a class="entry-link" aria-label="post link to brew 降级" href="https://kyzy540.github.io/post/brew_downgrade/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Zsh on macOS
    </h2>
  </header>
  <div class="entry-content">
    <p>前些日换Mac电脑，发现迁移zsh的配置有点繁琐，整了好一阵才顺手。索性写个文档记录下
先安装oh-my-zsh，和俩爱用的插件 (自动补全和高亮)
sh -c &#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&#34; &amp;&amp; \ git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions &amp;&amp; \ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 再来个Dracula主题
git clone https://github.com/dracula/zsh.git mv zsh/dracula.zsh-theme ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes mv zsh/lib ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes 改~/.zshrc，启用主题和插件，禁用自动更新 (自动更新影响shell启动速度)
ZSH_THEME=&#34;dracula&#34; zstyle &#39;:omz:update&#39; mode disabled # disable automatic updates plugins=(git history zsh-autosuggestions zsh-syntax-highlighting) 对于常用的alias，参考.zshrc备注，写到${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/aliases.zsh
同理，在custom目录下写pyenv.zsh初始化pyenv (omz的pyenv插件不好使)。写auth.zsh export 常用认证相关环境变量
希望对每个命令都奏效的环境变量写到~/.zshenv
# read even when Zsh is launched to run a single command export COPYFILE_DISABLE=1 # go export GOPATH=&#34;$HOME/go&#34; export PATH=&#34;$GOPATH/bin:$PATH&#34; 参考: What should/shouldn’t go in .zshenv, .zshrc, .zlogin, .zprofile, .zlogout?
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-08-19 10:18:44 +0800 CST'>August 19, 2024</span></footer>
  <a class="entry-link" aria-label="post link to Zsh on macOS" href="https://kyzy540.github.io/post/zsh_on_mac/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://kyzy540.github.io/tags/it/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://kyzy540.github.io/">低质量随笔</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
